
### 190. 颠倒二进制位
[TOC]
#### 解法1 取模求和
- 与反转十进制整数使用取模除十累加的方法类似，
    - 十进制：`ans = ans * 10 + n % 10; n = n / 10;`
    - 二进制：`ans = ans * 2 + n % 2; n = n / 2;`

- **但是**，仅仅使用这种写法，会有一些问题，比如都要考虑是否整型溢出，Java的整数溢出后的二进制数会表示成负数（补码形式），Java中负数除以2会向零取整；具体可以参考[这篇博客](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)还有这个[视频](https://www.bilibili.com/video/BV1NJ411k7VP)中: `-3 / 2 = -1` 而 `-3 >> 1 = -2`
- 然后还要考虑前导零，因为十进制是不考虑前面是否还有零的，比如`100`反转后就是`1`，不用写成`001`，而二进制要考虑前导零的问题。
- 所以综上所述，要使用位运算来避免溢出问题，同时循环32次。
- 因为一共只有32位，所以时间复杂度和空间复杂度都是`O(1)`。
```Java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
}
```
#### 解法2 按位翻转
- 直接颠倒计算每一位的数字
    - 32位 `int` 标记 `[0 ~ 31]`，如果 `n` 的第 `i` 位为`1`，则相应的`res` 第 `31 - i` 位应该为`1`
    - 类似地，如果 `n` 的第 `i` 位为`0`，则相应的 `res` 第 `31 - i` 位应该为`0`
1. res初始化为0，每次考虑 `n`的某一位，移动到颠倒后的位置，设该位表示的数为`temp`，`temp`只有两种情况，要么等于0，要么等于一个2的幂次(相当于二进制000... 1 ...0000这种形式)
2. 对于`temp = 0`，`res`加上`0`相当于没加，和`0`按位或、异或还是等于原来的数，所以这三者是一样的
3. 对于`temp = 2^(31 - i)`，temp二进制下只有一位为1，看样子似乎`+=`和`|=`不一样，但是不要忘了我们是按位循环的，当进行到`31 - i`这一位时，`res`的这一位还是`0`，那么就回到上一种情况了，`+=`,`|=`, `^=`这三种种写法其实还是等效的。
因为考虑的`temp`只有某一位，每次对应于`res`也是是其中某一位，而且由于是按位考虑，所以每次遍历到该位时，`res`二进制下的这一位也还是`0`，res |= ... , res += ... , res |= ...都是等价的，都是在表达，只要`temp`的该位为`1`，`res`该位就为`1`，因为`res`的那一位一开始是`0`，如果`temp`该位为`0`，由于`res`这一位也为`0`,那么`0 + 0`, `0 | 0`, `0 ^ 0`其实都等于`0`。三种写法都可以，但是更推荐使用位运算
```Java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i <= 31; i++) {            
            // res += (n & (1 << i)) != 0 ? 1 << (31 - i) : 0;
            // res |= (n & (1 << i)) != 0 ? 1 << (31 - i) : 0;
            res ^= (n & (1 << i)) != 0 ? 1 << (31 - i) : 0;
        }
        return res;
    }
}
```

#### 解法3:分治合并
- 既然知道 int 值一共32位，那么可以采用分治思想，反转左右16位，然后反转每个16位中的左右8位，依次类推，最后反转2位，反转后合并即可，同时可以利用位运算在原地反转。JDK中的Integer.bitCount()函数也是使用类似的方法。
- 这么说比较抽象，可以直接结合代码看下面的步骤，也可以拿代码在IDE中debug一下，看每一步都做了什么
1. 首先随便找一个数 (**为了看的清楚用`_`作分隔，可以忽略**)
`十进制43261596;   // 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬`
2. 左边16位移到右边，右边16位移到左边，然后使用`|`符号合并起来
    - Java中的无符号位移 `>>>`：无论是正数还是负数，高位通通补0。
    - `>>`：带符号右移。正数右移高位补0，负数右移高位补1。
    - `|`：按位或逻辑，该位只要有一位为`1`，结果就为`1`，这里用来合并
3. 使用一些有规律的数，将16位，再分成左右8位进行反转后合并，起始数字变为`‭0001 1110 1001 1100 _ 0000 0010 1001 0100‬`
    - `0xff00ff00` 表示16进制数`1111 1111 0000 0000 _ 1111 1111 0000 0000` ，
    - `0x00ff00ff` 表示16进制数`0000 0000 1111 1111 _ 0000 0000 1111 1111`，
 4. 重复以上步骤，分组、合并，最后得到反转后的结果。
 
 5. 总结来说就是利用位运算进行反转，同时存储反转后的数，继续分治进行反转，直到全部反转完成，变化过程为：
```xml
// 原数字43261596
 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬ 
// 反转左右16位：
‭ 0001 1110 1001 1100 _ 0000 0010 1001 0100‬ 
// 继续分为8位一组反转：
 1001 1100 0001 1110 _ 1001 0100 0000 0010
// 4位一组反转：
 1100 1001 1110 0001 _ 0100 1001 0010 0000‬
// 2位一组反转：
 0011 0110 1011 0100 _ 0001 0110 1000 0000
// 每两位再反转一下
‭ 0011 1001 0111 1000 _ 0010 1001 0100 0000‬‬
// 这就是43261596反转后的结果：‭964176192‬
```

```Java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        n = (n >>> 16) | (n << 16); 
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8); 
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4); 
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2); 
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1); 
        return n;
    }
}
```

- 解法三的补充：经 [@riptide](https://leetcode-cn.com/u/riptide-39/) 的提醒，`Integer` 包装类自带一个静态方法`Integer.reverse(int i)`，思想是一样的，写法略有不同，也提供给大家，有兴趣的也可以看看[这篇文章的分析](https://www.jianshu.com/p/be272c8704d9)

```Java
public static int reverse(int i) {

    i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
    i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
    i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
    i = (i << 24) | ((i & 0xff00) << 8) |
        ((i >>> 8) & 0xff00) | (i >>> 24);
    return i;
}
```


#### 巨人的肩膀

1. [huahua' leetcode 视频](https://www.bilibili.com/video/BV1NJ411k7VP)
2. [张子秋：原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
3. [苏小小北：Integer.reverse(int i)和reverseBytes](https://www.jianshu.com/p/be272c8704d9)