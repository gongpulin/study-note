#### 方法 1：循环和位移动

**算法**

这个方法比较直接。我们遍历数字的 32 位。如果某一位是 *1* ，将计数器加一。

我们使用 *位掩码* 来检查数字的第 *i^{th}* 位。一开始，掩码 *m=1* 因为 *1* 的二进制表示是

![0000\0000\0000\0000\0000\0000\0000\0001 ](./p___0000_0000_0000_0000_0000_0000_0000_0001__.png) 

显然，任何数字跟掩码 *1* 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。

![0000\0000\0000\0000\0000\0000\0000\0010 ](./p___0000_0000_0000_0000_0000_0000_0000_0010__.png) 

并重复此过程。

```Java []
public int hammingWeight(int n) {
    int bits = 0;
    int mask = 1;
    for (int i = 0; i < 32; i++) {
        if ((n & mask) != 0) {
            bits++;
        }
        mask <<= 1;
    }
    return bits;
}
```

**复杂度分析**

- 时间复杂度：*O(1)* 。运行时间依赖于数字 *n* 的位数。由于这题中 *n* 是一个 32 位数，所以运行时间是 *O(1)* 的。

- 空间复杂度：*O(1)*。没有使用额外空间。

#### 方法 2：位操作的小技巧

**算法**

我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 *1* 反转，并把答案加一。当数字变成 *0* 的时候偶，我们就知道它没有 *1* 的位了，此时返回答案。

这里关键的想法是对于任意数字 *n* ，将 *n* 和 *n - 1* 做与运算，会把最后一个 *1* 的位变成 *0* 。为什么？考虑 *n* 和 *n - 1* 的二进制表示。


 [image.png](https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png)


*图片 1. 将 *n* 和 *n-1* 做与运算会将最低位的 *1* 变成 *0**


在二进制表示中，数字 *n* 中最低位的 *1* 总是对应 *n - 1* 中的 *0* 。因此，将 *n* 和 *n - 1* 与运算总是能把 *n* 中最低位的 *1* 变成 *0* ，并保持其他位不变。

使用这个小技巧，代码变得非常简单。

```Java []
public int hammingWeight(int n) {
    int sum = 0;
    while (n != 0) {
        sum++;
        n &= (n - 1);
    }
    return sum;
}
```

**复杂度分析**

 - 时间复杂度：*O(1)* 。运行时间与 *n* 中位为 *1* 的有关。在最坏情况下， *n* 中所有位都是 *1* 。对于 32 位整数，运行时间是 *O(1)* 的。

 - 空间复杂度：*O(1)* 。没有使用额外空间。
